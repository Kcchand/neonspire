# telegram_bot.py
"""
NeonSpire Staff Bot
===================

Telegram staff panel for your casino dashboard.

- show dashboard counters
- list + approve/reject deposits
- provider-based "approve & credit" (juwa/gv/milkyway/vblink/ultrapanda)
- list + redeem/paid withdrawals
- list + approve/reject game-account requests
- list recent players
- üîî auto-poll DB and push NEW deposits/withdrawals/requests to staff
- üí¨ support inbox (reads from kv_store -> 'support:inbox' same as employee dashboard)
"""

import os
import json
import logging
from datetime import datetime

from dotenv import load_dotenv

load_dotenv(".env")

from telegram import (
    Update,
    InlineKeyboardMarkup,
    InlineKeyboardButton,
    ParseMode,
)
from telegram.ext import (
    Updater,
    CallbackContext,
    CommandHandler,
    CallbackQueryHandler,
)

# ---- Flask app + models -----------------------------
from app import app as flask_app
from models import (
    db,
    User,
    Game,
    PlayerBalance,
    GameAccount,
    GameAccountRequest,
    DepositRequest,
    WithdrawRequest,
    PaymentSettings,
    notify,
)

# üëá we need this to read from kv_store like employee dashboard
from sqlalchemy import text

# unified provider facade
from automation.providers import (
    detect_vendor,
    provider_credit,
    provider_redeem,
    provider_auto_create,
    result_ok as _prov_ok,
    result_error_text as _prov_err,
)

# --------------------------------------------------------------------
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
)
log = logging.getLogger("tg.staff")

TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
BOT_NAME = os.getenv("TELEGRAM_BOT_NAME", "NeonSpire Staff Bot")

_raw_staff = os.getenv("TELEGRAM_STAFF_IDS", "")
STAFF_IDS = {int(x.strip()) for x in _raw_staff.split(",") if x.strip().isdigit()}

PAGE_SIZE = 10
STATE_FILE = ".tg_staff_state.json"


# ================== STATE HELPERS ==================
def load_state() -> dict:
    if os.path.exists(STATE_FILE):
        try:
            with open(STATE_FILE, "r", encoding="utf-8") as f:
                return json.load(f)
        except Exception:
            return {}
    return {}


def save_state(state: dict):
    try:
        with open(STATE_FILE, "w", encoding="utf-8") as f:
            json.dump(state, f, indent=2, default=str)
    except Exception as e:
        log.warning("could not save state: %s", e)


# ================== UI HELPERS ==================
def _ack_working(q):
    """always show instant toast so staff knows tap was received."""
    try:
        q.answer("‚è≥ Working‚Ä¶", show_alert=False)
    except Exception:
        pass


def _send_progress_msg(bot, chat_id: int, text: str) -> int:
    msg = bot.send_message(chat_id=chat_id, text=text, parse_mode=ParseMode.MARKDOWN)
    return msg.message_id


def _set_loading_keyboard(q, label: str = "‚è≥ Working‚Ä¶"):
    try:
        q.edit_message_reply_markup(
            reply_markup=InlineKeyboardMarkup(
                [[InlineKeyboardButton(label, callback_data="noop")]]
            )
        )
    except Exception as e:
        log.debug("cannot edit keyboard to loading: %s", e)


def _set_loading(q, text: str):
    try:
        q.edit_message_text(text=text, parse_mode=ParseMode.MARKDOWN)
        return
    except Exception:
        pass
    try:
        q.message.edit_text(text=text, parse_mode=ParseMode.MARKDOWN)
        return
    except Exception:
        pass
    try:
        q.bot.edit_message_text(
            chat_id=q.message.chat_id,
            message_id=q.message.message_id,
            text=text,
            parse_mode=ParseMode.MARKDOWN,
        )
        return
    except Exception as e:
        log.warning("cannot show loading text: %s", e)
        try:
            q.answer("Processing‚Ä¶", show_alert=False)
        except Exception:
            pass


# ================== SUPPORT HELPERS ==================
def _read_support_inbox() -> list[dict]:
    """
    Read support inbox from the same place employee dashboard uses:
    kv_store -> key = 'support:inbox'
    We do NOT change the dashboard. We just read the same JSON.
    """
    with flask_app.app_context():
        try:
            row = db.session.execute(
                text("SELECT value FROM kv_store WHERE key = :k"),
                {"k": "support:inbox"},
            ).fetchone()
        except Exception as e:
            log.warning("support: cannot read kv_store: %s", e)
            return []

        if not row or not row[0]:
            return []

        try:
            data = json.loads(row[0])
        except Exception:
            return []

        # expect list of threads; if it's a dict wrap it
        if isinstance(data, dict):
            data = [data]
        if not isinstance(data, list):
            return []
        return data


def _support_menu_kb() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(
        [
            [InlineKeyboardButton("üîÑ Refresh", callback_data="list_support:0")],
        ]
    )


# ================== HELPERS ==================
def staff_only(update: Update) -> bool:
    uid = update.effective_user.id if update.effective_user else None
    if uid in STAFF_IDS:
        return True

    if update.message:
        update.message.reply_text("üö´ You are not allowed to use this staff bot.")
    elif update.callback_query:
        update.callback_query.answer("Not allowed.", show_alert=True)
    return False


def main_menu_kb() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(
        [
            [InlineKeyboardButton("üí∞ Deposits", callback_data="list_deposits:0")],
            [InlineKeyboardButton("üí∏ Withdrawals", callback_data="list_withdrawals:0")],
            [InlineKeyboardButton("üÜî Game requests", callback_data="list_requests:0")],
            [InlineKeyboardButton("üë• Players", callback_data="list_players:0")],
            # üëá this is the new one, to match employee dashboard
            [InlineKeyboardButton("üí¨ Support", callback_data="list_support:0")],
        ]
    )


def _display_name(user: User | None) -> str:
    if not user:
        return "‚Äî"
    return (user.name or user.email or f"User #{user.id}").strip()


def _player_login_for_game(user_id: int, game_id: int | None) -> str | None:
    if not game_id:
        return None
    acc = GameAccount.query.filter_by(user_id=user_id, game_id=game_id).first()
    if not acc:
        return None
    for f in ("account_username", "username", "login", "user"):
        if hasattr(acc, f):
            v = getattr(acc, f)
            if v:
                return v
    return None


def _vendor_for_game(game: Game | None) -> str | None:
    if not game:
        return None
    return detect_vendor(game)


def _add_wallet_balance(user_id: int, amount: int):
    wallet = PlayerBalance.query.filter_by(user_id=user_id).first()
    if wallet:
        wallet.balance = (wallet.balance or 0) + amount


# ================== COMMANDS ==================
def start_cmd(update: Update, context: CallbackContext):
    if not staff_only(update):
        return

    txt = (
        f"üëã *{BOT_NAME}*\n"
        "Process player deposits, approve/reject game login requests, pay withdrawals, and view players.\n\n"
        "Commands:\n"
        "/panel ‚Äì main menu\n"
        "/deposits ‚Äì list pending deposits\n"
        "/withdrawals ‚Äì list pending withdrawals\n"
        "/requests ‚Äì list pending game login requests\n"
        "/players ‚Äì list recent players\n"
        "/support ‚Äì support inbox\n"
    )
    update.message.reply_text(txt, parse_mode=ParseMode.MARKDOWN, reply_markup=main_menu_kb())


def panel_cmd(update: Update, context: CallbackContext):
    if not staff_only(update):
        return
    with flask_app.app_context():
        pending_deposits = DepositRequest.query.filter_by(status="PENDING").count()
        pending_requests = GameAccountRequest.query.filter(
            GameAccountRequest.status.in_(["PENDING", "IN_PROGRESS"])
        ).count()
        pending_withdraws = WithdrawRequest.query.filter_by(status="PENDING").count()

    txt = (
        "*Staff panel:*\n"
        f"üí∞ Pending deposits: *{pending_deposits}*\n"
        f"üÜî Pending game requests: *{pending_requests}*\n"
        f"üí∏ Pending withdrawals: *{pending_withdraws}*\n"
    )
    update.message.reply_text(txt, parse_mode=ParseMode.MARKDOWN, reply_markup=main_menu_kb())


def deposits_cmd(update: Update, context: CallbackContext):
    if not staff_only(update):
        return
    _send_deposits_list(update, page=0)


def withdrawals_cmd(update: Update, context: CallbackContext):
    if not staff_only(update):
        return
    _send_withdrawals_list(update, page=0)


def requests_cmd(update: Update, context: CallbackContext):
    if not staff_only(update):
        return
    _send_requests_list(update, page=0)


def players_cmd(update: Update, context: CallbackContext):
    if not staff_only(update):
        return
    _send_players_list(update, page=0)


def support_cmd(update: Update, context: CallbackContext):
    if not staff_only(update):
        return
    _send_support_list(update, page=0)


def whoami_cmd(update: Update, context: CallbackContext):
    user = update.effective_user
    uid = user.id if user else None
    uname = user.full_name if user else "unknown"
    update.message.reply_text(f"Your Telegram ID is: {uid}\nName: {uname}")


# ================== LIST SENDERS ==================
def _send_deposits_list(target, page: int):
    with flask_app.app_context():
        q = (
            DepositRequest.query.filter(DepositRequest.status.in_(["PENDING", "RECEIVED"]))
            .order_by(DepositRequest.created_at.asc())
        )
        total = q.count()
        rows = q.offset(page * PAGE_SIZE).limit(PAGE_SIZE).all()

    if not rows:
        if hasattr(target, "message"):
            target.message.reply_text("No pending deposits ‚úÖ", reply_markup=main_menu_kb())
        else:
            target.edit_message_text("No pending deposits ‚úÖ", reply_markup=main_menu_kb())
        return

    text_lines = [f"üí∞ *Pending deposits* (page {page+1})"]
    for d in rows:
        text_lines.append(f"- #{d.id} ‚Ä¢ user {d.user_id} ‚Ä¢ {d.amount} via {d.method}")
    text = "\n".join(text_lines)

    nav = []
    if page > 0:
        nav.append(InlineKeyboardButton("‚¨ÖÔ∏è Prev", callback_data=f"list_deposits:{page-1}"))
    if (page + 1) * PAGE_SIZE < total:
        nav.append(InlineKeyboardButton("‚û°Ô∏è Next", callback_data=f"list_deposits:{page+1}"))

    if hasattr(target, "message"):
        target.message.reply_text(text, parse_mode=ParseMode.MARKDOWN,
                                  reply_markup=InlineKeyboardMarkup([nav] if nav else []))
    else:
        target.edit_message_text(text, parse_mode=ParseMode.MARKDOWN,
                                 reply_markup=InlineKeyboardMarkup([nav] if nav else []))

    for d in rows:
        _send_deposit_card(target, d)


def _send_withdrawals_list(target, page: int):
    with flask_app.app_context():
        q = (
            WithdrawRequest.query.filter_by(status="PENDING")
            .order_by(WithdrawRequest.created_at.asc())
        )
        total = q.count()
        rows = q.offset(page * PAGE_SIZE).limit(PAGE_SIZE).all()

    if not rows:
        if hasattr(target, "message"):
            target.message.reply_text("No pending withdrawals ‚úÖ", reply_markup=main_menu_kb())
        else:
            target.edit_message_text("No pending withdrawals ‚úÖ", reply_markup=main_menu_kb())
        return

    text_lines = [f"üí∏ *Pending withdrawals* (page {page+1})"]
    for w in rows:
        text_lines.append(f"- #{w.id} ‚Ä¢ user {w.user_id} ‚Ä¢ {w.amount} via {w.method}")
    text = "\n".join(text_lines)

    nav = []
    if page > 0:
        nav.append(InlineKeyboardButton("‚¨ÖÔ∏è Prev", callback_data=f"list_withdrawals:{page-1}"))
    if (page + 1) * PAGE_SIZE < total:
        nav.append(InlineKeyboardButton("‚û°Ô∏è Next", callback_data=f"list_withdrawals:{page+1}"))

    if hasattr(target, "message"):
        target.message.reply_text(text, parse_mode=ParseMode.MARKDOWN,
                                  reply_markup=InlineKeyboardMarkup([nav] if nav else []))
    else:
        target.edit_message_text(text, parse_mode=ParseMode.MARKDOWN,
                                 reply_markup=InlineKeyboardMarkup([nav] if nav else []))

    for w in rows:
        _send_withdraw_card(target, w)


def _send_requests_list(target, page: int):
    with flask_app.app_context():
        q = (
            GameAccountRequest.query.filter(
                GameAccountRequest.status.in_(["PENDING", "IN_PROGRESS"])
            )
            .order_by(GameAccountRequest.created_at.asc())
        )
        total = q.count()
        rows = q.offset(page * PAGE_SIZE).limit(PAGE_SIZE).all()

    if not rows:
        if hasattr(target, "message"):
            target.message.reply_text("No pending game login requests ‚úÖ", reply_markup=main_menu_kb())
        else:
            target.edit_message_text("No pending game login requests ‚úÖ", reply_markup=main_menu_kb())
        return

    text_lines = [f"üÜî *Game login requests* (page {page+1})"]
    for r in rows:
        text_lines.append(f"- #{r.id} ‚Ä¢ user {r.user_id} ‚Ä¢ game {r.game_id} ‚Ä¢ {r.status}")
    text = "\n".join(text_lines)

    nav = []
    if page > 0:
        nav.append(InlineKeyboardButton("‚¨ÖÔ∏è Prev", callback_data=f"list_requests:{page-1}"))
    if (page + 1) * PAGE_SIZE < total:
        nav.append(InlineKeyboardButton("‚û°Ô∏è Next", callback_data=f"list_requests:{page+1}"))

    if hasattr(target, "message"):
        target.message.reply_text(text, parse_mode=ParseMode.MARKDOWN,
                                  reply_markup=InlineKeyboardMarkup([nav] if nav else []))
    else:
        target.edit_message_text(text, parse_mode=ParseMode.MARKDOWN,
                                 reply_markup=InlineKeyboardMarkup([nav] if nav else []))

    for r in rows:
        _send_request_card(target, r)


def _send_players_list(target, page: int):
    with flask_app.app_context():
        q = (
            User.query.filter_by(role="PLAYER")
            .order_by(User.created_at.desc())
        )
        total = q.count()
        rows = q.offset(page * PAGE_SIZE).limit(PAGE_SIZE).all()

    if not rows:
        if hasattr(target, "message"):
            target.message.reply_text("No players.", reply_markup=main_menu_kb())
        else:
            target.edit_message_text("No players.", reply_markup=main_menu_kb())
        return

    text_lines = [f"üë• *Players* (page {page+1})"]
    for u in rows:
        text_lines.append(f"- {u.id} ‚Ä¢ {_display_name(u)}")
    text = "\n".join(text_lines)

    nav = []
    if page > 0:
        nav.append(InlineKeyboardButton("‚¨ÖÔ∏è Prev", callback_data=f"list_players:{page-1}"))
    if (page + 1) * PAGE_SIZE < total:
        nav.append(InlineKeyboardButton("‚û°Ô∏è Next", callback_data=f"list_players:{page+1}"))

    if hasattr(target, "message"):
        target.message.reply_text(text, parse_mode=ParseMode.MARKDOWN,
                                  reply_markup=InlineKeyboardMarkup([nav] if nav else []))
    else:
        target.edit_message_text(text, parse_mode=ParseMode.MARKDOWN,
                                 reply_markup=InlineKeyboardMarkup([nav] if nav else []))


def _send_support_list(target, page: int):
    """Show support inbox from kv_store."""
    inbox = _read_support_inbox()

    if not inbox:
        # exactly what you saw
        if hasattr(target, "message"):
            target.message.reply_text("No support messages ‚úÖ", reply_markup=main_menu_kb())
        else:
            target.edit_message_text("No support messages ‚úÖ", reply_markup=main_menu_kb())
        return

    # paginate
    total = len(inbox)
    start = page * PAGE_SIZE
    end = start + PAGE_SIZE
    rows = inbox[start:end]

    text_lines = [f"üí¨ *Support inbox* (page {page+1})"]
    for item in rows:
        # try to be defensive because we don't know exact structure
        player_name = item.get("player_name") or item.get("name") or item.get("user_name") or "‚Äî"
        player_email = item.get("player_email") or item.get("email") or ""
        user_id = item.get("user_id") or item.get("uid") or item.get("id") or "?"
        last_msg = item.get("last_message") or item.get("message") or item.get("text") or "(no text)"
        updated_at = item.get("updated_at") or item.get("last_activity") or ""
        text_lines.append(
            f"‚Ä¢ {player_name} (id {user_id})\n  {last_msg}"
            + (f"\n  {player_email}" if player_email else "")
            + (f"\n  {updated_at}" if updated_at else "")
        )

    text = "\n".join(text_lines)

    nav = []
    if page > 0:
        nav.append(InlineKeyboardButton("‚¨ÖÔ∏è Prev", callback_data=f"list_support:{page-1}"))
    if end < total:
        nav.append(InlineKeyboardButton("‚û°Ô∏è Next", callback_data=f"list_support:{page+1}"))

    kb_rows = []
    if nav:
        kb_rows.append(nav)
    # button to refresh current page
    kb_rows.append([InlineKeyboardButton("üîÑ Refresh", callback_data=f"list_support:{page}")])

    if hasattr(target, "message"):
        target.message.reply_text(
            text,
            parse_mode=ParseMode.MARKDOWN,
            reply_markup=InlineKeyboardMarkup(kb_rows),
            disable_web_page_preview=True,
        )
    else:
        target.edit_message_text(
            text,
            parse_mode=ParseMode.MARKDOWN,
            reply_markup=InlineKeyboardMarkup(kb_rows),
            disable_web_page_preview=True,
        )


# ================== CARD SENDERS ==================
# ================== CARD SENDERS ==================
def _send_deposit_card(target, dep: DepositRequest):
    # ---- load related objects & meta inside Flask context ----
    with flask_app.app_context():
        user = db.session.get(User, dep.user_id) if dep.user_id else None
        game = db.session.get(Game, dep.game_id) if dep.game_id else None
        settings = db.session.get(PaymentSettings, 1)

        # meta can be dict (JSON column) or JSON string
        meta = {}
        try:
            if isinstance(dep.meta, dict):
                meta = dep.meta
            elif dep.meta:
                meta = json.loads(dep.meta)
        except Exception:
            meta = {}

    uname = _display_name(user)
    gname = game.name if game else "‚Äî"

    # ------------- base lines (same for all methods) -------------
    lines = [
        f"üí∞ *Deposit #{dep.id}*",
        f"Player: {uname} (id {dep.user_id})",
        f"Amount: *{dep.amount}*",
        f"Method: `{dep.method or '-'}`",
        f"Game: {gname}",
        f"Status: {dep.status}",
    ]

    if dep.created_at:
        lines.append(f"Created: `{dep.created_at:%Y-%m-%d %H:%M}`")

    # ------------- method-specific details (match employee dashboard) -------------
    detail_lines = []

    method = (dep.method or "").upper()

    if method == "CHIME":
        payer_name = (meta.get("payer_name") or "").strip()
        payer_handle = (
            meta.get("payer_handle")
            or meta.get("payer_contact")
            or meta.get("chime_handle")
            or ""
        ).strip()

        # fallback to global CHIME handle like dashboard
        if not (payer_name or payer_handle) and settings and getattr(settings, "chime_handle", None):
            payer_handle = settings.chime_handle

        if payer_name:
            detail_lines.append(f"Name: {payer_name}")
        if payer_handle:
            detail_lines.append(f"Handle: `{payer_handle}`")

    elif method == "CRYPTO":
        from_addr = (
            meta.get("payer_wallet")
            or meta.get("payer_address")
            or meta.get("crypto_from")
            or ""
        ).strip()
        net = (meta.get("network") or meta.get("chain") or "").strip()

        if from_addr:
            detail_lines.append(f"From: `{from_addr}`")
        if net:
            detail_lines.append(f"Network: {net}")

    elif method == "CASHAPP":
        cash_tag = (
            meta.get("payer_cashtag")
            or meta.get("payer_handle")
            or meta.get("payer_contact")
            or ""
        ).strip()
        if cash_tag:
            detail_lines.append(f"From: `{cash_tag}`")

    # ------------- proof link (always show something) -------------
    proof_url_raw = (dep.proof_url or "").strip() or (meta.get("proof_url") or "").strip()
    proof_display = proof_url_raw
    proof_link = None

    if proof_url_raw:
        proof_link = proof_url_raw

        # build full URL if it's relative (/static/...)
        if not proof_link.lower().startswith(("http://", "https://")):
            base = (
                flask_app.config.get("EXTERNAL_BASE_URL")
                or os.getenv("EXTERNAL_BASE_URL", "")
            )
            if base.endswith("/"):
                base = base[:-1]
            if not proof_link.startswith("/"):
                proof_link = "/" + proof_link
            if base:
                proof_link = base + proof_link

        # if we successfully got http/https, make it clickable,
        # otherwise show plain text path
        if proof_link.lower().startswith(("http://", "https://")):
            detail_lines.append(f"[View proof]({proof_link})")
        else:
            # still show the path so staff can copy it
            detail_lines.append(f"Proof: `{proof_display}`")

    # ------------- assemble text -------------
    if detail_lines:
        lines.append("")
        lines.append("*Details:*")
        lines.extend(detail_lines)

    text = "\n".join(lines)

    kb = InlineKeyboardMarkup(
        [
            [
                InlineKeyboardButton("‚úÖ Mark LOADED", callback_data=f"dep_loaded:{dep.id}"),
                InlineKeyboardButton("ü§ñ Approve+Credit", callback_data=f"dep_auto:{dep.id}"),
            ],
            [InlineKeyboardButton("‚ùå Reject", callback_data=f"dep_reject:{dep.id}")],
        ]
    )

    if hasattr(target, "message"):
        target.message.reply_text(
            text,
            parse_mode=ParseMode.MARKDOWN,
            disable_web_page_preview=True,
            reply_markup=kb,
        )
    else:
        target.edit_message_text(
            text,
            parse_mode=ParseMode.MARKDOWN,
            disable_web_page_preview=True,
            reply_markup=kb,
        )


def _send_withdraw_card(target, wd: WithdrawRequest):
    # Make withdrawal card mirror employee Withdrawals page
    with flask_app.app_context():
        user = db.session.get(User, wd.user_id) if wd.user_id else None
        game = db.session.get(Game, wd.game_id) if wd.game_id else None
        wallet = PlayerBalance.query.filter_by(user_id=wd.user_id).first()
        login = _player_login_for_game(wd.user_id, wd.game_id)

    uname = _display_name(user)
    gname = game.name if game else "‚Äî"

    # ---------- base section ----------
    lines = [
        f"üí∏ *Withdrawal #{wd.id}*",
        f"Player: {uname} (id {wd.user_id})",
        f"Game: {gname}",
    ]
    if login:
        lines.append(f"Login: `{login}`")

    lines.extend(
        [
            f"Amount: *{wd.amount}*",
            f"Method: `{wd.method or '-'}`",
            f"Status: {wd.status}",
        ]
    )

    if wd.created_at:
        lines.append(f"Requested: `{wd.created_at:%Y-%m-%d %H:%M}`")

    # ---------- details (wallet, totals, address, tip etc.) ----------
    detail_lines = []

    # current wallet balance
    if wallet and wallet.balance is not None:
        detail_lines.append(f"Wallet: *{int(wallet.balance)}*")

    # optional totals if model has them
    if getattr(wd, "total_amount", None):
        detail_lines.append(f"Total: *{wd.total_amount}*")
    if getattr(wd, "keep_amount", None):
        detail_lines.append(f"Keep in wallet: *{wd.keep_amount}*")
    if getattr(wd, "tip_amount", None) and wd.tip_amount > 0:
        detail_lines.append(f"Tip: *{wd.tip_amount}*")

    # destination address / handle
    addr = (getattr(wd, "address", "") or "").strip()
    if addr:
        method = (wd.method or "").upper()
        if method == "CRYPTO":
            label = "Address"
        elif method == "CHIME":
            label = "Chime"
        else:
            label = "Destination"
        detail_lines.append(f"{label}: `{addr}`")

    if detail_lines:
        lines.append("")
        lines.append("*Details:*")
        lines.extend(detail_lines)

    text = "\n".join(lines)

    kb = InlineKeyboardMarkup(
        [
            [
                InlineKeyboardButton("üîÅ Redeem", callback_data=f"wd_redeem:{wd.id}"),
                InlineKeyboardButton("‚úÖ Mark PAID", callback_data=f"wd_paid:{wd.id}"),
            ],
            [InlineKeyboardButton("‚ùå Reject", callback_data=f"wd_reject:{wd.id}")],
        ]
    )

    if hasattr(target, "message"):
        target.message.reply_text(
            text,
            parse_mode=ParseMode.MARKDOWN,
            reply_markup=kb,
        )
    else:
        target.edit_message_text(
            text,
            parse_mode=ParseMode.MARKDOWN,
            reply_markup=kb,
        )


def _send_request_card(target, req: GameAccountRequest):
    with flask_app.app_context():
        user = db.session.get(User, req.user_id) if req.user_id else None
        game = db.session.get(Game, req.game_id) if req.game_id else None
    uname = _display_name(user)
    gname = game.name if game else "‚Äî"
    lines = [
        f"üÜî *Game request #{req.id}*",
        f"Player: {uname} (id {req.user_id})",
        f"Game: {gname}",
        f"Status: {req.status}",
    ]
    text = "\n".join(lines)
    kb = InlineKeyboardMarkup(
        [
            [
                InlineKeyboardButton("‚úÖ Approve", callback_data=f"req_ok:{req.id}"),
                InlineKeyboardButton("‚ùå Reject", callback_data=f"req_no:{req.id}"),
            ],
            [
                InlineKeyboardButton("ü§ñ Auto-provision", callback_data=f"req_auto:{req.id}"),
                InlineKeyboardButton("‚è≥ In progress", callback_data=f"req_prog:{req.id}"),
            ],
        ]
    )
    if hasattr(target, "message"):
        target.message.reply_text(text, parse_mode=ParseMode.MARKDOWN, reply_markup=kb)
    else:
        target.edit_message_text(text, parse_mode=ParseMode.MARKDOWN, reply_markup=kb)


# ================== CALLBACK HANDLER ==================
def callback_handler(update: Update, context: CallbackContext):
    if not staff_only(update):
        return

    q = update.callback_query
    data = q.data or ""
    # NOTE: we will call q.answer(...) again in actions to show ‚Äúworking‚Ä¶‚Äù
    q.answer()

    # lists
    if data.startswith("list_deposits:"):
        page = int(data.split(":", 1)[1])
        _send_deposits_list(q, page)
        return
    if data.startswith("list_withdrawals:"):
        page = int(data.split(":", 1)[1])
        _send_withdrawals_list(q, page)
        return
    if data.startswith("list_requests:"):
        page = int(data.split(":", 1)[1])
        _send_requests_list(q, page)
        return
    if data.startswith("list_players:"):
        page = int(data.split(":", 1)[1])
        _send_players_list(q, page)
        return
    if data.startswith("list_support:"):
        page = int(data.split(":", 1)[1])
        _send_support_list(q, page)
        return

    # ================== DEPOSITS ==================
    if data.startswith("dep_loaded:"):
        dep_id = int(data.split(":", 1)[1])
        chat_id = q.message.chat_id
        _ack_working(q)
        _set_loading_keyboard(q)
        progress_mid = _send_progress_msg(context.bot, chat_id, f"‚è≥ Marking deposit #{dep_id} as LOADED‚Ä¶")
        with flask_app.app_context():
            dep = db.session.get(DepositRequest, dep_id)
            if not dep:
                context.bot.edit_message_text(chat_id=chat_id, message_id=progress_mid, text="Deposit not found.")
                return
            dep.status = "LOADED"
            dep.loaded_at = datetime.utcnow()
            _add_wallet_balance(dep.user_id, int(dep.amount or 0))
            db.session.commit()
            notify(dep.user_id, f"‚úÖ Your deposit #{dep.id} of {dep.amount} has been loaded.")
        context.bot.edit_message_text(chat_id=chat_id, message_id=progress_mid,
                                      text=f"Deposit #{dep_id} ‚úÖ marked LOADED.")
        return

    if data.startswith("dep_reject:"):
        dep_id = int(data.split(":", 1)[1])
        chat_id = q.message.chat_id
        _ack_working(q)
        _set_loading_keyboard(q)
        progress_mid = _send_progress_msg(context.bot, chat_id, f"‚è≥ Rejecting deposit #{dep_id}‚Ä¶")
        with flask_app.app_context():
            dep = db.session.get(DepositRequest, dep_id)
            if not dep:
                context.bot.edit_message_text(chat_id=chat_id, message_id=progress_mid, text="Deposit not found.")
                return
            dep.status = "REJECTED"
            db.session.commit()
            notify(dep.user_id, f"‚ùå Your deposit #{dep.id} was rejected. Please contact support.")
        context.bot.edit_message_text(chat_id=chat_id, message_id=progress_mid,
                                      text=f"Deposit #{dep_id} ‚ùå rejected.")
        return

    if data.startswith("dep_auto:"):
        dep_id = int(data.split(":", 1)[1])
        chat_id = q.message.chat_id
        _ack_working(q)
        _set_loading_keyboard(q)
        progress_mid = _send_progress_msg(context.bot, chat_id, f"‚è≥ Crediting deposit #{dep_id}‚Ä¶")
        with flask_app.app_context():
            dep = db.session.get(DepositRequest, dep_id)
            if not dep:
                context.bot.edit_message_text(chat_id=chat_id, message_id=progress_mid, text="Deposit not found.")
                return
            if dep.status not in ("PENDING", "RECEIVED"):
                context.bot.edit_message_text(
                    chat_id=chat_id,
                    message_id=progress_mid,
                    text=f"Deposit #{dep.id} has status {dep.status}, not PENDING/RECEIVED.",
                )
                return
            game = db.session.get(Game, dep.game_id) if dep.game_id else None
            vendor = _vendor_for_game(game)
            if not vendor:
                context.bot.edit_message_text(chat_id=chat_id, message_id=progress_mid,
                                              text="Vendor not recognized for this game.")
                return
            acc_username = _player_login_for_game(dep.user_id, dep.game_id)
            if not acc_username:
                context.bot.edit_message_text(
                    chat_id=chat_id,
                    message_id=progress_mid,
                    text="Player has no saved login for this game/vendor.",
                )
                return
            amount = int(dep.amount or 0)
            if amount <= 0:
                context.bot.edit_message_text(chat_id=chat_id, message_id=progress_mid, text="Amount must be > 0")
                return

            note = f"Deposit#{dep.id} via Telegram"
            try:
                res = provider_credit(vendor, acc_username, amount, note)
            except Exception as e:
                msg = str(e)
                if "Locator.click" in msg or "Timeout 60000ms" in msg or "recharge" in msg.lower():
                    context.bot.edit_message_text(
                        chat_id=chat_id,
                        message_id=progress_mid,
                        text="‚ö†Ô∏è JUWA recharge failed.\nPlease try again or load it manually in the JUWA panel.",
                    )
                else:
                    context.bot.edit_message_text(
                        chat_id=chat_id,
                        message_id=progress_mid,
                        text=f"{vendor.upper()} credit failed: {msg}",
                    )
                return

            if not _prov_ok(vendor, res):
                err_txt = _prov_err(res) or "unknown error"
                context.bot.edit_message_text(
                    chat_id=chat_id,
                    message_id=progress_mid,
                    text=f"‚ö†Ô∏è {vendor.upper()} recharge failed.\nReason: {err_txt}\nTry again or do it manually.",
                )
                return

            dep.status = "LOADED"
            dep.loaded_at = datetime.utcnow()
            _add_wallet_balance(dep.user_id, amount)
            db.session.commit()
            notify(dep.user_id, f"‚úÖ Your deposit #{dep.id} of {amount} has been credited to {vendor.upper()}.")
        context.bot.edit_message_text(
            chat_id=chat_id,
            message_id=progress_mid,
            text=f"Deposit #{dep_id} ‚úÖ credited on vendor and marked LOADED.",
        )
        return

    # ================== WITHDRAWALS ==================
    if data.startswith("wd_redeem:"):
        wd_id = int(data.split(":", 1)[1])
        chat_id = q.message.chat_id
        _ack_working(q)
        _set_loading_keyboard(q)
        progress_mid = _send_progress_msg(context.bot, chat_id, f"‚è≥ Redeeming withdrawal #{wd_id}‚Ä¶")
        with flask_app.app_context():
            wd = db.session.get(WithdrawRequest, wd_id)
            if not wd:
                context.bot.edit_message_text(chat_id=chat_id, message_id=progress_mid, text="Withdrawal not found.")
                return
            game = db.session.get(Game, wd.game_id) if wd.game_id else None
            vendor = _vendor_for_game(game)
            acc_username = _player_login_for_game(wd.user_id, wd.game_id) if wd.game_id else None

            if (not acc_username) or (not vendor):
                accs = GameAccount.query.filter_by(user_id=wd.user_id).all()
                for a in accs:
                    g = db.session.get(Game, a.game_id) if a.game_id else None
                    v = _vendor_for_game(g)
                    if v:
                        acc_username = acc_username or (
                            a.account_username or a.username or a.login or a.user
                        )
                        vendor = vendor or v
                        if acc_username and vendor:
                            break

            if not acc_username or not vendor:
                context.bot.edit_message_text(
                    chat_id=chat_id,
                    message_id=progress_mid,
                    text="Cannot redeem: no username/vendor found for player.",
                )
                return

            amount = int(wd.amount or 0)
            if amount <= 0:
                context.bot.edit_message_text(
                    chat_id=chat_id,
                    message_id=progress_mid,
                    text="Redeem amount must be > 0.",
                )
                return

            try:
                res = provider_redeem(vendor, acc_username, amount, f"Withdraw #{wd.id}")
            except Exception as e:
                context.bot.edit_message_text(
                    chat_id=chat_id,
                    message_id=progress_mid,
                    text=f"Redeem error: {e}",
                )
                return
            if not _prov_ok(vendor, res):
                context.bot.edit_message_text(
                    chat_id=chat_id,
                    message_id=progress_mid,
                    text=f"Redeem failed: {_prov_err(res)}",
                )
                return

            wd.status = "APPROVED"
            db.session.commit()
            notify(wd.user_id, f"üîì Your withdrawal #{wd.id} was redeemed and is awaiting payout.")
        context.bot.edit_message_text(
            chat_id=chat_id,
            message_id=progress_mid,
            text=f"Withdrawal #{wd_id} ‚úÖ redeemed on {vendor.upper()}.",
        )
        return

    if data.startswith("wd_paid:"):
        wd_id = int(data.split(":", 1)[1])
        chat_id = q.message.chat_id
        _ack_working(q)
        _set_loading_keyboard(q)
        progress_mid = _send_progress_msg(context.bot, chat_id, f"‚è≥ Marking withdrawal #{wd_id} as PAID‚Ä¶")
        with flask_app.app_context():
            wd = db.session.get(WithdrawRequest, wd_id)
            if not wd:
                context.bot.edit_message_text(chat_id=chat_id, message_id=progress_mid, text="Withdrawal not found.")
                return
            wd.status = "PAID"
            wd.paid_at = datetime.utcnow()
            wallet = PlayerBalance.query.filter_by(user_id=wd.user_id).first()
            if wallet:
                wallet.balance = max(0, (wallet.balance or 0) - (wd.amount or 0))
            db.session.commit()
            notify(wd.user_id, f"üí∏ Your withdrawal #{wd.id} for {wd.amount} has been paid.")
        context.bot.edit_message_text(
            chat_id=chat_id,
            message_id=progress_mid,
            text=f"Withdrawal #{wd_id} ‚úÖ marked PAID.",
        )
        return

    if data.startswith("wd_reject:"):
        wd_id = int(data.split(":", 1)[1])
        chat_id = q.message.chat_id
        _ack_working(q)
        _set_loading_keyboard(q)
        progress_mid = _send_progress_msg(context.bot, chat_id, f"‚è≥ Rejecting withdrawal #{wd_id}‚Ä¶")
        with flask_app.app_context():
            wd = db.session.get(WithdrawRequest, wd_id)
            if not wd:
                context.bot.edit_message_text(chat_id=chat_id, message_id=progress_mid, text="Withdrawal not found.")
                return
            wd.status = "REJECTED"
            db.session.commit()
            notify(wd.user_id, f"‚ö†Ô∏è Your withdrawal #{wd.id} was rejected. Contact support.")
        context.bot.edit_message_text(
            chat_id=chat_id,
            message_id=progress_mid,
            text=f"Withdrawal #{wd_id} ‚ùå rejected.",
        )
        return

    # ================== GAME REQUESTS ==================
    if data.startswith("req_ok:"):
        req_id = int(data.split(":", 1)[1])
        chat_id = q.message.chat_id
        _ack_working(q)
        _set_loading_keyboard(q)
        progress_mid = _send_progress_msg(context.bot, chat_id, f"‚è≥ Approving game request #{req_id}‚Ä¶")
        with flask_app.app_context():
            req = db.session.get(GameAccountRequest, req_id)
            if not req:
                context.bot.edit_message_text(chat_id=chat_id, message_id=progress_mid, text="Request not found.")
                return
            req.status = "APPROVED"
            req.approved_at = datetime.utcnow()
            db.session.commit()
            notify(req.user_id, f"‚úÖ Your game login request #{req.id} was approved. Open My Logins.")
        context.bot.edit_message_text(
            chat_id=chat_id,
            message_id=progress_mid,
            text=f"Game request #{req_id} ‚úÖ approved.",
        )
        return

    if data.startswith("req_no:"):
        req_id = int(data.split(":", 1)[1])
        chat_id = q.message.chat_id
        _ack_working(q)
        _set_loading_keyboard(q)
        progress_mid = _send_progress_msg(context.bot, chat_id, f"‚è≥ Rejecting game request #{req_id}‚Ä¶")
        with flask_app.app_context():
            req = db.session.get(GameAccountRequest, req_id)
            if not req:
                context.bot.edit_message_text(chat_id=chat_id, message_id=progress_mid, text="Request not found.")
                return
            if (req.status or "").upper() not in ("APPROVED", "PROVIDED", "REJECTED"):
                req.status = "REJECTED"
                db.session.commit()
                notify(req.user_id, f"‚ö†Ô∏è Your game login request #{req.id} was rejected.")
        context.bot.edit_message_text(
            chat_id=chat_id,
            message_id=progress_mid,
            text=f"Game request #{req_id} ‚ùå rejected.",
        )
        return

    if data.startswith("req_prog:"):
        req_id = int(data.split(":", 1)[1])
        chat_id = q.message.chat_id
        _ack_working(q)
        _set_loading_keyboard(q)
        progress_mid = _send_progress_msg(context.bot, chat_id, f"‚è≥ Marking game request #{req_id} IN_PROGRESS‚Ä¶")
        with flask_app.app_context():
            req = db.session.get(GameAccountRequest, req_id)
            if not req:
                context.bot.edit_message_text(chat_id=chat_id, message_id=progress_mid, text="Request not found.")
                return
            req.status = "IN_PROGRESS"
            db.session.commit()
        context.bot.edit_message_text(
            chat_id=chat_id,
            message_id=progress_mid,
            text=f"Game request #{req_id} ‚è≥ marked IN_PROGRESS.",
        )
        return

    if data.startswith("req_auto:"):
        req_id = int(data.split(":", 1)[1])
        chat_id = q.message.chat_id
        _ack_working(q)
        _set_loading_keyboard(q)
        progress_mid = _send_progress_msg(context.bot, chat_id, f"‚è≥ Auto-provisioning for request #{req_id}‚Ä¶")
        with flask_app.app_context():
            req = db.session.get(GameAccountRequest, req_id)
            if not req:
                context.bot.edit_message_text(chat_id=chat_id, message_id=progress_mid, text="Request not found.")
                return
            game = db.session.get(Game, req.game_id) if req.game_id else None
            vendor = _vendor_for_game(game)
            if vendor != "milkyway":
                context.bot.edit_message_text(
                    chat_id=chat_id,
                    message_id=progress_mid,
                    text="Auto-provision supported only for Milkyway (in this build).",
                )
                return
            try:
                r = provider_auto_create(vendor)
            except Exception as e:
                context.bot.edit_message_text(
                    chat_id=chat_id,
                    message_id=progress_mid,
                    text=f"Auto-provision error: {e}",
                )
                return
            if not isinstance(r, dict) or not r.get("ok"):
                context.bot.edit_message_text(
                    chat_id=chat_id,
                    message_id=progress_mid,
                    text=f"Auto-provision failed: {r}",
                )
                return

            username = r.get("username")
            password = r.get("password") or username
            note = r.get("note") or "Auto-provisioned via Telegram"

            acc = GameAccount.query.filter_by(user_id=req.user_id, game_id=req.game_id).first()
            if not acc:
                acc = GameAccount(user_id=req.user_id, game_id=req.game_id)
                db.session.add(acc)

            for f in ("account_username", "username", "login", "user"):
                if hasattr(acc, f):
                    setattr(acc, f, username)
                    break
            for f in ("account_password", "password", "passcode", "pin"):
                if hasattr(acc, f):
                    setattr(acc, f, password)
                    break
            if hasattr(acc, "extra"):
                acc.extra = note

            req.status = "APPROVED"
            req.approved_at = datetime.utcnow()
            db.session.commit()
            notify(req.user_id, "ü§ñ Your Milkyway login was issued. Open My Logins.")
        context.bot.edit_message_text(
            chat_id=chat_id,
            message_id=progress_mid,
            text=f"Game request #{req_id} ü§ñ auto-provisioned.",
        )
        return


# ================== AUTO-POLL JOB ==================
def poll_new_items(context: CallbackContext):
    job_ctx = context.job.context
    state = job_ctx["state"]
    staff_ids = job_ctx["staff_ids"]

    try:
        with flask_app.app_context():
            last_dep_id = state.get("last_dep_id", 0)
            new_deps = (
                db.session.query(DepositRequest)
                .filter(DepositRequest.id > last_dep_id)
                .order_by(DepositRequest.id.asc())
                .all()
            )
            for dep in new_deps:
                if (dep.status or "").upper() not in ("PENDING", "RECEIVED"):
                    state["last_dep_id"] = dep.id
                    continue

                user = db.session.get(User, dep.user_id) if dep.user_id else None
                game = db.session.get(Game, dep.game_id) if dep.game_id else None
                settings = db.session.get(PaymentSettings, 1)

                # decode meta safely
                meta = {}
                try:
                    if isinstance(dep.meta, dict):
                        meta = dep.meta
                    elif dep.meta:
                        meta = json.loads(dep.meta)
                except Exception:
                    meta = {}

                method = (dep.method or "").upper()

                text_msg = (
                    f"üí∞ *New deposit* #{dep.id}\n"
                    f"Player: {_display_name(user)} (id {dep.user_id})\n"
                    f"Amount: *{dep.amount}*\n"
                    f"Method: {dep.method or '-'}\n"
                    f"Game: {game.name if game else '-'}\n"
                )

                # ---- CHIME extra info ----
                if method == "CHIME":
                    payer_name = (meta.get("payer_name") or "").strip()
                    payer_handle = (
                        meta.get("payer_handle")
                        or meta.get("payer_contact")
                        or meta.get("chime_handle")
                        or ""
                    ).strip()

                    # same fallback as card: global CHIME handle from PaymentSettings
                    if not (payer_name or payer_handle) and settings and getattr(settings, "chime_handle", None):
                        payer_handle = settings.chime_handle

                    if payer_name:
                        text_msg += f"Name: {payer_name}\n"
                    if payer_handle:
                        text_msg += f"Handle: `{payer_handle}`\n"

                # ---- CRYPTO extra info ----
                elif method == "CRYPTO":
                    from_addr = (
                        meta.get("payer_wallet")
                        or meta.get("payer_address")
                        or meta.get("crypto_from")
                        or ""
                    ).strip()
                    net = (meta.get("network") or meta.get("chain") or "").strip()

                    if from_addr:
                        text_msg += f"From: `{from_addr}`\n"
                    if net:
                        text_msg += f"Network: {net}\n"

                kb = InlineKeyboardMarkup(
                    [
                        [
                            InlineKeyboardButton("‚úÖ Mark LOADED", callback_data=f"dep_loaded:{dep.id}"),
                            InlineKeyboardButton("ü§ñ Approve+Credit", callback_data=f"dep_auto:{dep.id}"),
                        ],
                        [InlineKeyboardButton("‚ùå Reject", callback_data=f"dep_reject:{dep.id}")],
                    ]
                )

                for sid in staff_ids:
                    try:
                        context.bot.send_message(
                            chat_id=sid,
                            text=text_msg,
                            parse_mode=ParseMode.MARKDOWN,
                            reply_markup=kb,
                            disable_web_page_preview=True,
                        )
                    except Exception as e:
                        log.warning("cannot push deposit to %s: %s", sid, e)

                state["last_dep_id"] = dep.id

            last_wd_id = state.get("last_wd_id", 0)
            new_wds = (
                db.session.query(WithdrawRequest)
                .filter(WithdrawRequest.id > last_wd_id)
                .order_by(WithdrawRequest.id.asc())
                .all()
            )
            for wd in new_wds:
                if (wd.status or "").upper() not in ("PENDING",):
                    state["last_wd_id"] = wd.id
                    continue

                user = db.session.get(User, wd.user_id) if wd.user_id else None
                game = db.session.get(Game, wd.game_id) if wd.game_id else None
                wallet = PlayerBalance.query.filter_by(user_id=wd.user_id).first()

                text_msg = (
                    f"üí∏ *New withdrawal* #{wd.id}\n"
                    f"Player: {_display_name(user)} (id {wd.user_id})\n"
                    f"Amount: *{wd.amount}*\n"
                    f"Method: {wd.method or '-'}\n"
                    f"Game: {game.name if game else '-'}\n"
                )

                # same style as withdrawal card
                if wallet and wallet.balance is not None:
                    text_msg += f"Wallet: *{int(wallet.balance)}*\n"

                if getattr(wd, "total_amount", None):
                    text_msg += f"Total: *{wd.total_amount}*\n"
                if getattr(wd, "keep_amount", None):
                    text_msg += f"Keep in wallet: *{wd.keep_amount}*\n"
                if getattr(wd, "tip_amount", None) and wd.tip_amount > 0:
                    text_msg += f"Tip: *{wd.tip_amount}*\n"

                addr = (getattr(wd, "address", "") or "").strip()
                if addr:
                    method = (wd.method or "").upper()
                    if method == "CRYPTO":
                        label = "Address"
                    elif method == "CHIME":
                        label = "Chime"
                    else:
                        label = "Destination"
                    text_msg += f"{label}: `{addr}`\n"

                kb = InlineKeyboardMarkup(
                    [
                        [
                            InlineKeyboardButton("üîÅ Redeem", callback_data=f"wd_redeem:{wd.id}"),
                            InlineKeyboardButton("‚úÖ Mark PAID", callback_data=f"wd_paid:{wd.id}"),
                        ],
                        [InlineKeyboardButton("‚ùå Reject", callback_data=f"wd_reject:{wd.id}")],
                    ]
                )
                for sid in staff_ids:
                    try:
                        context.bot.send_message(
                            chat_id=sid,
                            text=text_msg,
                            parse_mode=ParseMode.MARKDOWN,
                            reply_markup=kb,
                        )
                    except Exception as e:
                        log.warning("cannot push withdraw to %s: %s", sid, e)

                state["last_wd_id"] = wd.id

            last_acc_id = state.get("last_acc_id", 0)
            new_accs = (
                db.session.query(GameAccountRequest)
                .filter(GameAccountRequest.id > last_acc_id)
                .order_by(GameAccountRequest.id.asc())
                .all()
            )
            for req in new_accs:
                if (req.status or "").upper() not in ("PENDING", "IN_PROGRESS"):
                    state["last_acc_id"] = req.id
                    continue

                user = db.session.get(User, req.user_id) if req.user_id else None
                game = db.session.get(Game, req.game_id) if req.game_id else None

                text_msg = (
                    f"üÜî *New game account request* #{req.id}\n"
                    f"Player: {_display_name(user)} (id {req.user_id})\n"
                    f"Game: {game.name if game else '-'}\n"
                )
                kb = InlineKeyboardMarkup(
                    [
                        [
                            InlineKeyboardButton("‚úÖ Approve", callback_data=f"req_ok:{req.id}"),
                            InlineKeyboardButton("‚ùå Reject", callback_data=f"req_no:{req.id}"),
                        ],
                        [
                            InlineKeyboardButton("ü§ñ Auto-provision", callback_data=f"req_auto:{req.id}"),
                            InlineKeyboardButton("‚è≥ In progress", callback_data=f"req_prog:{req.id}"),
                        ],
                    ]
                )
                for sid in staff_ids:
                    try:
                        context.bot.send_message(
                            chat_id=sid,
                            text=text_msg,
                            parse_mode=ParseMode.MARKDOWN,
                            reply_markup=kb,
                        )
                    except Exception as e:
                        log.warning("cannot push account req to %s: %s", sid, e)

                state["last_acc_id"] = req.id

            # ----------------- OPTIONAL: notify counts like before -----------------
            pending_dep_count = (
                db.session.query(DepositRequest)
                .filter(DepositRequest.status.in_(["PENDING", "RECEIVED"]))
                .count()
            )
            pending_wd_count = (
                db.session.query(WithdrawRequest)
                .filter(WithdrawRequest.status.in_(["PENDING"]))
                .count()
            )
            pending_acc_count = (
                db.session.query(GameAccountRequest)
                .filter(GameAccountRequest.status.in_(["PENDING", "IN_PROGRESS"]))
                .count()
            )

            last_dep_count = state.get("last_dep_count", 0)
            last_wd_count = state.get("last_wd_count", 0)
            last_acc_count = state.get("last_acc_count", 0)

            if pending_dep_count > 0 and pending_dep_count != last_dep_count:
                for sid in staff_ids:
                    try:
                        context.bot.send_message(chat_id=sid, text="‚ö†Ô∏è New deposit pending. Tap /deposits")
                    except Exception as e:
                        log.warning("cannot send dep notice: %s", e)
                state["last_dep_count"] = pending_dep_count

            if pending_wd_count > 0 and pending_wd_count != last_wd_count:
                for sid in staff_ids:
                    try:
                        context.bot.send_message(chat_id=sid, text="‚ö†Ô∏è New withdrawal pending. Tap /withdrawals")
                    except Exception as e:
                        log.warning("cannot send wd notice: %s", e)
                state["last_wd_count"] = pending_wd_count

            if pending_acc_count > 0 and pending_acc_count != last_acc_count:
                for sid in staff_ids:
                    try:
                        context.bot.send_message(chat_id=sid, text="‚ö†Ô∏è New game account request. Tap /requests")
                    except Exception as e:
                        log.warning("cannot send acc notice: %s", e)
                state["last_acc_count"] = pending_acc_count

            save_state(state)

    except Exception as e:
        log.exception("poll_new_items crashed: %s", e)


# ================== EXTERNAL HELPER (for Flask) ==================
def notify_withdraw_request(user, amount, method, address, game_name):
    """
    Called from Flask when a player submits a withdrawal request.
    Sends formatted message to all staff Telegram IDs.
    """
    try:
        from telegram import Bot
        bot = Bot(token=TOKEN)
        msg = (
            f"üí∏ *New Withdrawal Request*\n"
            f"üë§ Player: `{user.username}` (id {user.id})\n"
            f"üéÆ Game: {game_name}\n"
            f"üí∞ Amount: *${amount}*\n"
            f"üè¶ Method: {method}\n"
            f"üì§ Destination: `{address}`\n"
            f"‚è≥ Status: Pending approval"
        )
        for sid in STAFF_IDS:
            try:
                bot.send_message(chat_id=sid, text=msg, parse_mode="Markdown")
            except Exception as inner_e:
                log.warning("Failed to send withdraw alert to %s: %s", sid, inner_e)
    except Exception as e:
        log.warning("notify_withdraw_request() failed: %s", e)
# ================== MAIN ==================
def main():
    if not TOKEN:
        raise SystemExit("TELEGRAM_BOT_TOKEN missing in .env")

    updater = Updater(TOKEN, use_context=True)
    dp = updater.dispatcher

    dp.add_handler(CommandHandler("whoami", whoami_cmd))
    dp.add_handler(CommandHandler("start", start_cmd))
    dp.add_handler(CommandHandler("panel", panel_cmd))
    dp.add_handler(CommandHandler("deposits", deposits_cmd))
    dp.add_handler(CommandHandler("withdrawals", withdrawals_cmd))
    dp.add_handler(CommandHandler("requests", requests_cmd))
    dp.add_handler(CommandHandler("players", players_cmd))
    dp.add_handler(CommandHandler("support", support_cmd))  # üëà new

    dp.add_handler(CallbackQueryHandler(callback_handler))

    state = load_state()
    with flask_app.app_context():
        if "last_dep_id" not in state:
            last_dep = db.session.query(DepositRequest.id).order_by(DepositRequest.id.desc()).first()
            state["last_dep_id"] = last_dep[0] if last_dep else 0
        if "last_wd_id" not in state:
            last_wd = db.session.query(WithdrawRequest.id).order_by(WithdrawRequest.id.desc()).first()
            state["last_wd_id"] = last_wd[0] if last_wd else 0
        if "last_acc_id" not in state:
            last_acc = db.session.query(GameAccountRequest.id).order_by(GameAccountRequest.id.desc()).first()
            state["last_acc_id"] = last_acc[0] if last_acc else 0
    save_state(state)

    job_context = {
        "state": state,
        "staff_ids": STAFF_IDS,
    }

    updater.job_queue.run_repeating(
        poll_new_items,
        interval=5,
        first=5,
        context=job_context,
    )

    log.info("Telegram staff bot started with live monitoring.")
    updater.start_polling()
    updater.idle()


if __name__ == "__main__":
    main()
# =====================================================================
# OVERRIDES: richer player info + email for game requests + notifications
# (these definitions come AFTER the originals and safely override them)
# =====================================================================

def _send_players_list(target, page: int):
    """
    Players list with:
    - id + display name
    - email (if any)
    - Telegram name + ID (if stored)
    - games played + count
    """
    with flask_app.app_context():
        q = (
            User.query.filter_by(role="PLAYER")
            .order_by(User.created_at.desc())
        )
        total = q.count()
        rows = q.offset(page * PAGE_SIZE).limit(PAGE_SIZE).all()

        if not rows:
            if hasattr(target, "message"):
                target.message.reply_text("No players.", reply_markup=main_menu_kb())
            else:
                target.edit_message_text("No players.", reply_markup=main_menu_kb())
            return

        text_lines = [f"üë• *Players* (page {page+1})"]

        for u in rows:
            # Basic identity
            text_lines.append(f"- {u.id} ‚Ä¢ {_display_name(u)}")

            # Email
            email = getattr(u, "email", None)
            if email:
                text_lines.append(f"  üìß {email}")

            # Telegram info (for mini app players if you save it)
            tg_id = (
                getattr(u, "telegram_id", None)
                or getattr(u, "tg_id", None)
            )
            tg_name = (
                getattr(u, "telegram_name", None)
                or getattr(u, "tg_name", None)
                or getattr(u, "telegram_username", None)
            )
            if tg_id or tg_name:
                if tg_name and tg_id:
                    text_lines.append(f"  üì≤ Telegram: {tg_name} (id {tg_id})")
                elif tg_id:
                    text_lines.append(f"  üì≤ Telegram id: {tg_id}")
                else:
                    text_lines.append(f"  üì≤ Telegram: {tg_name}")

            # Games and game count
            game_names = []
            try:
                accs = GameAccount.query.filter_by(user_id=u.id).all()
                for acc in accs:
                    g = db.session.get(Game, acc.game_id) if acc.game_id else None
                    if g and g.name and g.name not in game_names:
                        game_names.append(g.name)
            except Exception:
                game_names = []

            if game_names:
                text_lines.append(
                    f"  üéÆ Games ({len(game_names)}): {', '.join(game_names)}"
                )

        text = "\n".join(text_lines)

        nav = []
        if page > 0:
            nav.append(InlineKeyboardButton("‚¨ÖÔ∏è Prev", callback_data=f"list_players:{page-1}"))
        if (page + 1) * PAGE_SIZE < total:
            nav.append(InlineKeyboardButton("‚û°Ô∏è Next", callback_data=f"list_players:{page+1}"))

    if hasattr(target, "message"):
        target.message.reply_text(
            text,
            parse_mode=ParseMode.MARKDOWN,
            reply_markup=InlineKeyboardMarkup([nav] if nav else []),
        )
    else:
        target.edit_message_text(
            text,
            parse_mode=ParseMode.MARKDOWN,
            reply_markup=InlineKeyboardMarkup([nav] if nav else []),
        )


def _send_request_card(target, req: GameAccountRequest):
    """
    Game login request card with email included.
    """
    with flask_app.app_context():
        user = db.session.get(User, req.user_id) if req.user_id else None
        game = db.session.get(Game, req.game_id) if req.game_id else None

    uname = _display_name(user)
    email = getattr(user, "email", None)
    gname = game.name if game else "‚Äî"

    lines = [
        f"üÜî *Game request #{req.id}*",
        f"Player: {uname} (id {req.user_id})",
    ]
    if email:
        lines.append(f"Email: {email}")
    lines.extend(
        [
            f"Game: {gname}",
            f"Status: {req.status}",
        ]
    )

    text = "\n".join(lines)
    kb = InlineKeyboardMarkup(
        [
            [
                InlineKeyboardButton("‚úÖ Approve", callback_data=f"req_ok:{req.id}"),
                InlineKeyboardButton("‚ùå Reject", callback_data=f"req_no:{req.id}"),
            ],
            [
                InlineKeyboardButton("ü§ñ Auto-provision", callback_data=f"req_auto:{req.id}"),
                InlineKeyboardButton("‚è≥ In progress", callback_data=f"req_prog:{req.id}"),
            ],
        ]
    )
    if hasattr(target, "message"):
        target.message.reply_text(text, parse_mode=ParseMode.MARKDOWN, reply_markup=kb)
    else:
        target.edit_message_text(text, parse_mode=ParseMode.MARKDOWN, reply_markup=kb)


def poll_new_items(context: CallbackContext):
    """
    Override of poll_new_items:
    - same behaviour as your original
    - BUT game-request notifications now also show player email + status
    """
    job_ctx = context.job.context
    state = job_ctx["state"]
    staff_ids = job_ctx["staff_ids"]

    try:
        with flask_app.app_context():
            # --------- NEW DEPOSITS ----------
            last_dep_id = state.get("last_dep_id", 0)
            new_deps = (
                db.session.query(DepositRequest)
                .filter(DepositRequest.id > last_dep_id)
                .order_by(DepositRequest.id.asc())
                .all()
            )
            for dep in new_deps:
                if (dep.status or "").upper() not in ("PENDING", "RECEIVED"):
                    state["last_dep_id"] = dep.id
                    continue

                user = db.session.get(User, dep.user_id) if dep.user_id else None
                game = db.session.get(Game, dep.game_id) if dep.game_id else None
                settings = db.session.get(PaymentSettings, 1)

                meta = {}
                try:
                    if isinstance(dep.meta, dict):
                        meta = dep.meta
                    elif dep.meta:
                        meta = json.loads(dep.meta)
                except Exception:
                    meta = {}

                method = (dep.method or "").upper()

                text_msg = (
                    f"üí∞ *New deposit* #{dep.id}\n"
                    f"Player: {_display_name(user)} (id {dep.user_id})\n"
                    f"Amount: *{dep.amount}*\n"
                    f"Method: {dep.method or '-'}\n"
                    f"Game: {game.name if game else '-'}\n"
                )

                if method == "CHIME":
                    payer_name = (meta.get("payer_name") or "").strip()
                    payer_handle = (
                        meta.get("payer_handle")
                        or meta.get("payer_contact")
                        or meta.get("chime_handle")
                        or ""
                    ).strip()
                    if not (payer_name or payer_handle) and settings and getattr(settings, "chime_handle", None):
                        payer_handle = settings.chime_handle
                    if payer_name:
                        text_msg += f"Name: {payer_name}\n"
                    if payer_handle:
                        text_msg += f"Handle: `{payer_handle}`\n"

                elif method == "CRYPTO":
                    from_addr = (
                        meta.get("payer_wallet")
                        or meta.get("payer_address")
                        or meta.get("crypto_from")
                        or ""
                    ).strip()
                    net = (meta.get("network") or meta.get("chain") or "").strip()
                    if from_addr:
                        text_msg += f"From: `{from_addr}`\n"
                    if net:
                        text_msg += f"Network: {net}\n"

                kb = InlineKeyboardMarkup(
                    [
                        [
                            InlineKeyboardButton("‚úÖ Mark LOADED", callback_data=f"dep_loaded:{dep.id}"),
                            InlineKeyboardButton("ü§ñ Approve+Credit", callback_data=f"dep_auto:{dep.id}"),
                        ],
                        [InlineKeyboardButton("‚ùå Reject", callback_data=f"dep_reject:{dep.id}")],
                    ]
                )

                for sid in staff_ids:
                    try:
                        context.bot.send_message(
                            chat_id=sid,
                            text=text_msg,
                            parse_mode=ParseMode.MARKDOWN,
                            reply_markup=kb,
                            disable_web_page_preview=True,
                        )
                    except Exception as e:
                        log.warning("cannot push deposit to %s: %s", sid, e)

                state["last_dep_id"] = dep.id

            # --------- NEW WITHDRAWALS ----------
            last_wd_id = state.get("last_wd_id", 0)
            new_wds = (
                db.session.query(WithdrawRequest)
                .filter(WithdrawRequest.id > last_wd_id)
                .order_by(WithdrawRequest.id.asc())
                .all()
            )
            for wd in new_wds:
                if (wd.status or "").upper() not in ("PENDING",):
                    state["last_wd_id"] = wd.id
                    continue

                user = db.session.get(User, wd.user_id) if wd.user_id else None
                game = db.session.get(Game, wd.game_id) if wd.game_id else None
                wallet = PlayerBalance.query.filter_by(user_id=wd.user_id).first()

                text_msg = (
                    f"üí∏ *New withdrawal* #{wd.id}\n"
                    f"Player: {_display_name(user)} (id {wd.user_id})\n"
                    f"Amount: *{wd.amount}*\n"
                    f"Method: {wd.method or '-'}\n"
                    f"Game: {game.name if game else '-'}\n"
                )

                if wallet and wallet.balance is not None:
                    text_msg += f"Wallet: *{int(wallet.balance)}*\n"

                if getattr(wd, "total_amount", None):
                    text_msg += f"Total: *{wd.total_amount}*\n"
                if getattr(wd, "keep_amount", None):
                    text_msg += f"Keep in wallet: *{wd.keep_amount}*\n"
                if getattr(wd, "tip_amount", None) and wd.tip_amount > 0:
                    text_msg += f"Tip: *{wd.tip_amount}*\n"

                addr = (getattr(wd, "address", "") or "").strip()
                if addr:
                    method = (wd.method or "").upper()
                    if method == "CRYPTO":
                        label = "Address"
                    elif method == "CHIME":
                        label = "Chime"
                    else:
                        label = "Destination"
                    text_msg += f"{label}: `{addr}`\n"

                kb = InlineKeyboardMarkup(
                    [
                        [
                            InlineKeyboardButton("üîÅ Redeem", callback_data=f"wd_redeem:{wd.id}"),
                            InlineKeyboardButton("‚úÖ Mark PAID", callback_data=f"wd_paid:{wd.id}"),
                        ],
                        [InlineKeyboardButton("‚ùå Reject", callback_data=f"wd_reject:{wd.id}")],
                    ]
                )
                for sid in staff_ids:
                    try:
                        context.bot.send_message(
                            chat_id=sid,
                            text=text_msg,
                            parse_mode=ParseMode.MARKDOWN,
                            reply_markup=kb,
                        )
                    except Exception as e:
                        log.warning("cannot push withdraw to %s: %s", sid, e)

                state["last_wd_id"] = wd.id

            # --------- NEW GAME ACCOUNT REQUESTS ----------
            last_acc_id = state.get("last_acc_id", 0)
            new_accs = (
                db.session.query(GameAccountRequest)
                .filter(GameAccountRequest.id > last_acc_id)
                .order_by(GameAccountRequest.id.asc())
                .all()
            )
            for req in new_accs:
                if (req.status or "").upper() not in ("PENDING", "IN_PROGRESS"):
                    state["last_acc_id"] = req.id
                    continue

                user = db.session.get(User, req.user_id) if req.user_id else None
                game = db.session.get(Game, req.game_id) if req.game_id else None

                email = getattr(user, "email", None)

                text_msg = (
                    f"üÜî *New game account request* #{req.id}\n"
                    f"Player: {_display_name(user)} (id {req.user_id})\n"
                )
                if email:
                    text_msg += f"Email: {email}\n"
                text_msg += (
                    f"Game: {game.name if game else '-'}\n"
                    f"Status: {req.status}\n"
                )

                kb = InlineKeyboardMarkup(
                    [
                        [
                            InlineKeyboardButton("‚úÖ Approve", callback_data=f"req_ok:{req.id}"),
                            InlineKeyboardButton("‚ùå Reject", callback_data=f"req_no:{req.id}"),
                        ],
                        [
                            InlineKeyboardButton("ü§ñ Auto-provision", callback_data=f"req_auto:{req.id}"),
                            InlineKeyboardButton("‚è≥ In progress", callback_data=f"req_prog:{req.id}"),
                        ],
                    ]
                )
                for sid in staff_ids:
                    try:
                        context.bot.send_message(
                            chat_id=sid,
                            text=text_msg,
                            parse_mode=ParseMode.MARKDOWN,
                            reply_markup=kb,
                        )
                    except Exception as e:
                        log.warning("cannot push account req to %s: %s", sid, e)

                state["last_acc_id"] = req.id

            # --------- COUNTS (same as before) ----------
            pending_dep_count = (
                db.session.query(DepositRequest)
                .filter(DepositRequest.status.in_(["PENDING", "RECEIVED"]))
                .count()
            )
            pending_wd_count = (
                db.session.query(WithdrawRequest)
                .filter(WithdrawRequest.status.in_(["PENDING"]))
                .count()
            )
            pending_acc_count = (
                db.session.query(GameAccountRequest)
                .filter(GameAccountRequest.status.in_(["PENDING", "IN_PROGRESS"]))
                .count()
            )

            last_dep_count = state.get("last_dep_count", 0)
            last_wd_count = state.get("last_wd_count", 0)
            last_acc_count = state.get("last_acc_count", 0)

            if pending_dep_count > 0 and pending_dep_count != last_dep_count:
                for sid in staff_ids:
                    try:
                        context.bot.send_message(chat_id=sid, text="‚ö†Ô∏è New deposit pending. Tap /deposits")
                    except Exception as e:
                        log.warning("cannot send dep notice: %s", e)
                state["last_dep_count"] = pending_dep_count

            if pending_wd_count > 0 and pending_wd_count != last_wd_count:
                for sid in staff_ids:
                    try:
                        context.bot.send_message(chat_id=sid, text="‚ö†Ô∏è New withdrawal pending. Tap /withdrawals")
                    except Exception as e:
                        log.warning("cannot send wd notice: %s", e)
                state["last_wd_count"] = pending_wd_count

            if pending_acc_count > 0 and pending_acc_count != last_acc_count:
                for sid in staff_ids:
                    try:
                        context.bot.send_message(chat_id=sid, text="‚ö†Ô∏è New game account request. Tap /requests")
                    except Exception as e:
                        log.warning("cannot send acc notice: %s", e)
                state["last_acc_count"] = pending_acc_count

            save_state(state)

    except Exception as e:
        log.exception("poll_new_items crashed: %s", e)

# ===== OVERRIDE: Rich player list =====
def _send_players_list(target, page: int):
    with flask_app.app_context():
        q = User.query.filter_by(role="PLAYER").order_by(User.created_at.desc())
        total = q.count()
        rows = q.offset(page * PAGE_SIZE).limit(PAGE_SIZE).all()

    if not rows:
        msg = "No players."
        if hasattr(target, "message"):
            return target.message.reply_text(msg, reply_markup=main_menu_kb())
        return target.edit_message_text(msg, reply_markup=main_menu_kb())

    lines = [f"üë• *Players* (page {page+1}) ‚Äî Total: {total}"]

    for u in rows:
        name = _display_name(u)
        email = (getattr(u, "email", "") or "").strip()

        tg_id = getattr(u, "telegram_id", None) or getattr(u, "tg_id", None)
        tg_name = (
            getattr(u, "telegram_name", None)
            or getattr(u, "telegram_username", None)
            or getattr(u, "telegram_handle", None)
        )

        # collect games for this player
        with flask_app.app_context():
            accs = GameAccount.query.filter_by(user_id=u.id).all()
            game_names = []
            for acc in accs:
                g = db.session.get(Game, acc.game_id) if acc.game_id else None
                if g and g.name:
                    game_names.append(g.name)

        # unique list keeping order
        seen = set()
        guniq = []
        for n in game_names:
            if n not in seen:
                seen.add(n)
                guniq.append(n)

        parts = []
        if email:
            parts.append(email)
        if guniq:
            short = ", ".join(guniq[:3])
            if len(guniq) > 3:
                short += "‚Ä¶"
            parts.append(f"{len(guniq)} games: {short}")
        if tg_id or tg_name:
            if tg_name and tg_id:
                parts.append(f"TG: {tg_name} ({tg_id})")
            elif tg_name:
                parts.append(f"TG: {tg_name}")
            else:
                parts.append(f"TG id: {tg_id}")

        detail = " ‚Äî " + " | ".join(parts) if parts else ""
        lines.append(f"- {u.id} ‚Ä¢ {name}{detail}")

    msg = "\\n".join(lines)

    nav = []
    if page > 0:
        nav.append(InlineKeyboardButton("‚¨ÖÔ∏è Prev", callback_data=f"list_players:{page-1}"))
    if (page + 1) * PAGE_SIZE < total:
        nav.append(InlineKeyboardButton("‚û°Ô∏è Next", callback_data=f"list_players:{page+1}"))

    kb = InlineKeyboardMarkup([nav]) if nav else None

    if hasattr(target, "message"):
        target.message.reply_text(msg, parse_mode=ParseMode.MARKDOWN, reply_markup=kb)
    else:
        target.edit_message_text(msg, parse_mode=ParseMode.MARKDOWN, reply_markup=kb)


# ===== OVERRIDE: Rich player list =====
def _send_players_list(target, page: int):
    """
    Rich players list:
    - ID + name
    - email
    - total games + game names
    - Telegram info (if fields exist on User)
    """
    with flask_app.app_context():
        q = User.query.filter_by(role="PLAYER").order_by(User.created_at.desc())
        total = q.count()
        rows = q.offset(page * PAGE_SIZE).limit(PAGE_SIZE).all()

    if not rows:
        msg = "No players."
        if hasattr(target, "message"):
            return target.message.reply_text(msg, reply_markup=main_menu_kb())
        return target.edit_message_text(msg, reply_markup=main_menu_kb())

    lines = [f"üë• *Players* (page {page+1}) ‚Äî Total: {total}"]

    for u in rows:
        name = _display_name(u)
        email = (getattr(u, "email", "") or "").strip()

        # Telegram info (optional fields)
        tg_id = getattr(u, "telegram_id", None) or getattr(u, "tg_id", None)
        tg_name = (
            getattr(u, "telegram_name", None)
            or getattr(u, "telegram_username", None)
            or getattr(u, "telegram_handle", None)
        )

        # Collect game names for this player
        with flask_app.app_context():
            accs = GameAccount.query.filter_by(user_id=u.id).all()
            game_names = []
            for acc in accs:
                g = db.session.get(Game, acc.game_id) if acc.game_id else None
                if g and g.name:
                    game_names.append(g.name)

        # Unique game names in order
        seen = set()
        unique_games = []
        for gname in game_names:
            if gname not in seen:
                seen.add(gname)
                unique_games.append(gname)

        parts = []
        if email:
            parts.append(email)

        if unique_games:
            short = ", ".join(unique_games[:3])
            if len(unique_games) > 3:
                short += "‚Ä¶"
            parts.append(f"{len(unique_games)} games: {short}")

        if tg_id or tg_name:
            if tg_name and tg_id:
                parts.append(f"TG: {tg_name} ({tg_id})")
            elif tg_name:
                parts.append(f"TG: {tg_name}")
            else:
                parts.append(f"TG id: {tg_id}")

        details = " ‚Äî " + " | ".join(parts) if parts else ""
        lines.append(f"- {u.id} ‚Ä¢ {name}{details}")

    msg = "\n".join(lines)

    # Navigation buttons
    nav = []
    if page > 0:
        nav.append(InlineKeyboardButton("‚¨ÖÔ∏è Prev", callback_data=f"list_players:{page-1}"))
    if (page + 1) * PAGE_SIZE < total:
        nav.append(InlineKeyboardButton("‚û°Ô∏è Next", callback_data=f"list_players:{page+1}"))

    kb = InlineKeyboardMarkup([nav]) if nav else None

    if hasattr(target, "message"):
        return target.message.reply_text(
            msg,
            parse_mode=ParseMode.MARKDOWN,
            reply_markup=kb,
        )
    return target.edit_message_text(
        msg,
        parse_mode=ParseMode.MARKDOWN,
        reply_markup=kb,
    )

# ===== OVERRIDE: Rich player list (FINAL) =====
def _send_players_list(target, page: int):
    """
    Rich players list:
    - id + name
    - email
    - Telegram info (if stored)
    - games + count
    - registered time
    """
    with flask_app.app_context():
        q = User.query.filter_by(role="PLAYER").order_by(User.created_at.desc())
        total = q.count()
        rows = q.offset(page * PAGE_SIZE).limit(PAGE_SIZE).all()

        if not rows:
            msg = "No players."
            if hasattr(target, "message"):
                return target.message.reply_text(msg, reply_markup=main_menu_kb())
            return target.edit_message_text(msg, reply_markup=main_menu_kb())

        lines = [f"üë• *Players* (page {page+1}) ‚Äî Total: {total}"]

        for u in rows:
            name = _display_name(u)

            # basic header line
            lines.append(f"- {u.id} ‚Ä¢ {name}")

            # email
            email = (getattr(u, "email", "") or "").strip()
            if email:
                lines.append(f"  üìß {email}")

            # Telegram info (mini-app players)
            tg_id = getattr(u, "telegram_id", None) or getattr(u, "tg_id", None)
            tg_name = (
                getattr(u, "telegram_name", None)
                or getattr(u, "tg_name", None)
                or getattr(u, "telegram_username", None)
                or getattr(u, "telegram_handle", None)
            )
            if tg_id or tg_name:
                if tg_name and tg_id:
                    lines.append(f"  üì≤ Telegram: {tg_name} (id {tg_id})")
                elif tg_name:
                    lines.append(f"  üì≤ Telegram: {tg_name}")
                else:
                    lines.append(f"  üì≤ Telegram id: {tg_id}")

            # games
            game_names = []
            try:
                accs = GameAccount.query.filter_by(user_id=u.id).all()
                for acc in accs:
                    g = db.session.get(Game, acc.game_id) if acc.game_id else None
                    if g and g.name and g.name not in game_names:
                        game_names.append(g.name)
            except Exception:
                game_names = []

            if game_names:
                # limit to first 5 names in display
                shown = ", ".join(game_names[:5])
                if len(game_names) > 5:
                    shown += "‚Ä¶"
                lines.append(f"  üéÆ Games ({len(game_names)}): {shown}")

            # registered time
            created_at = getattr(u, "created_at", None)
            if created_at:
                try:
                    lines.append(f"  üïí Joined: {created_at:%Y-%m-%d %H:%M}")
                except Exception:
                    lines.append(f"  üïí Joined: {created_at}")

        text = "\n".join(lines)

        # pagination
        nav = []
        if page > 0:
            nav.append(InlineKeyboardButton("‚¨ÖÔ∏è Prev", callback_data=f"list_players:{page-1}"))
        if (page + 1) * PAGE_SIZE < total:
            nav.append(InlineKeyboardButton("‚û°Ô∏è Next", callback_data=f"list_players:{page+1}"))

    kb = InlineKeyboardMarkup([nav]) if nav else None

    if hasattr(target, "message"):
        return target.message.reply_text(
            text,
            parse_mode=ParseMode.MARKDOWN,
            reply_markup=kb,
        )
    return target.edit_message_text(

# ===== OVERRIDE: Rich player list (FINAL CLEAN) =====
def _send_players_list(target, page: int):
    """
    Rich players list:
    - ID + name
    - email
    - Telegram username / ID (if stored)
    - games count + names
    - registration time
    """
    with flask_app.app_context():
        q = User.query.filter_by(role="PLAYER").order_by(User.created_at.desc())
        total = q.count()
        rows = q.offset(page * PAGE_SIZE).limit(PAGE_SIZE).all()

        if not rows:
            msg = "No players."
            if hasattr(target, "message"):
                return target.message.reply_text(msg, reply_markup=main_menu_kb())
            return target.edit_message_text(msg, reply_markup=main_menu_kb())

        lines = [f"üë• *Players* (page {page+1}) ‚Äî Total: {total}"]

        for u in rows:
            name = _display_name(u)
            lines.append(f"- {u.id} ‚Ä¢ {name}")

            # email
            email = (getattr(u, "email", "") or "").strip()
            if email:
                lines.append(f"  üìß {email}")

            # Telegram info
            tg_id = getattr(u, "telegram_id", None) or getattr(u, "tg_id", None)
            tg_name = (
                getattr(u, "telegram_name", None)
                or getattr(u, "telegram_username", None)
                or getattr(u, "telegram_handle", None)
            )
            if tg_id or tg_name:
                if tg_name and tg_id:
                    lines.append(f"  üì≤ Telegram: {tg_name} (id {tg_id})")
                elif tg_name:
                    lines.append(f"  üì≤ Telegram: {tg_name}")
                else:
                    lines.append(f"  üì≤ Telegram id: {tg_id}")

            # games
            game_names = []
            try:
                accs = GameAccount.query.filter_by(user_id=u.id).all()
                for acc in accs:
                    g = db.session.get(Game, acc.game_id) if acc.game_id else None
                    if g and g.name and g.name not in game_names:
                        game_names.append(g.name)
            except:
                pass

            if game_names:
                show = ", ".join(game_names[:3])
                if len(game_names) > 3:
                    show += "‚Ä¶"
                lines.append(f"  üéÆ Games ({len(game_names)}): {show}")

            # registration date
            if u.created_at:
                try:
                    lines.append(f"  üïí Joined: {u.created_at:%Y-%m-%d %H:%M}")
                except:
                    lines.append(f"  üïí Joined: {u.created_at}")

        text = "\n".join(lines)

    # pagination
    nav = []
    if page > 0:
        nav.append(InlineKeyboardButton("‚¨ÖÔ∏è Prev", callback_data=f"list_players:{page-1}"))
    if (page + 1) * PAGE_SIZE < total:
        nav.append(InlineKeyboardButton("‚û°Ô∏è Next", callback_data=f"list_players:{page+1}"))

    kb = InlineKeyboardMarkup([nav]) if nav else None

    if hasattr(target, "message"):
        return target.message.reply_text(text, parse_mode=ParseMode.MARKDOWN, reply_markup=kb)
    return target.edit_message_text(text, parse_mode=ParseMode.MARKDOWN, reply_markup=kb)

